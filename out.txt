In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ext/alloc_traits.h:36:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h: In instantiation of ‘struct std::allocator_traits<char>’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3087:63:   required from ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’
Noz.hpp:529:5:   required from ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:88:43: エラー: ‘char’ is not a class, struct, or union type
       typedef typename _Alloc::value_type value_type;
                                           ^~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:95:70: エラー: ‘char’ is not a class, struct, or union type
       using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
                                                                      ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:135:79: エラー: ‘char’ is not a class, struct, or union type
       using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
                                                                               ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h: In instantiation of ‘struct std::allocator_traits<char>::_Ptr<std::__allocator_traits_base::__v_pointer, void, void>’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:143:66:   required from ‘struct std::allocator_traits<char>’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3087:63:   required from ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’
Noz.hpp:529:5:   required from ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:102:71: エラー: ‘char’ is not a class, struct, or union type
    using type = typename pointer_traits<pointer>::template rebind<_Tp>;
                                                                       ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h: In instantiation of ‘struct std::allocator_traits<char>::_Ptr<std::__allocator_traits_base::__cv_pointer, const void, void>’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:151:79:   required from ‘struct std::allocator_traits<char>’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3087:63:   required from ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’
Noz.hpp:529:5:   required from ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:102:71: エラー: ‘char’ is not a class, struct, or union type
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h: In instantiation of ‘struct std::allocator_traits<char>’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3087:63:   required from ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’
Noz.hpp:529:5:   required from ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:159:68: エラー: ‘char’ is not a class, struct, or union type
       using difference_type = typename _Diff<_Alloc, pointer>::type;
                                                                    ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:167:70: エラー: ‘char’ is not a class, struct, or union type
       using size_type = typename _Size<_Alloc, difference_type>::type;
                                                                      ^
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h: In instantiation of ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’:
Noz.hpp:529:5:   required from ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3087:63: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
       typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                                                               ^~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3100:68: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
       typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                                                                    ^~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3102:61: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
                                                             const_iterator;
                                                             ^~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3103:53: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                                                     ^~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3104:52: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
       typedef std::reverse_iterator<iterator>      reverse_iterator;
                                                    ^~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5213:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  find(const _Tp& __svt, size_type __pos = 0) const
  ^~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5291:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  rfind(const _Tp& __svt, size_type __pos = npos) const
  ^~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5375:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  find_first_of(const _Tp& __svt, size_type __pos = 0) const
  ^~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5459:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  find_last_of(const _Tp& __svt, size_type __pos = npos) const
  ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5540:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
  ^~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:5622:2: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
  ^~~~~~~~~~~~~~~~
In file included from Noz.cpp:1:0:
Noz.hpp: In instantiation of ‘class Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >’:
Noz.cpp:264:44:   required from here
Noz.hpp:529:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘begin’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:529:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘begin’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:529:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘begin’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:529:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘begin’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:530:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘end’; did you mean ‘append’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:530:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘end’; did you mean ‘append’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:530:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘end’; did you mean ‘append’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:530:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘end’; did you mean ‘append’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:531:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cbegin’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:531:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cbegin’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:531:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cbegin’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:531:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cbegin’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:532:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cend’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:532:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cend’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:532:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cend’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:532:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘cend’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:533:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rbegin’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:533:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rbegin’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:533:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rbegin’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:533:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rbegin’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:534:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rend’; did you mean ‘append’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:534:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rend’; did you mean ‘append’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:534:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rend’; did you mean ‘append’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:534:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rend’; did you mean ‘append’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:535:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crbegin’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:535:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crbegin’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:535:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crbegin’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:535:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crbegin’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:536:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crend’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:536:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crend’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:536:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crend’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:536:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘crend’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:537:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘size’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:537:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘size’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:537:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘size’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:537:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘size’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:538:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘length’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:538:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘length’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:538:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘length’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:538:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘length’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:539:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘max_size’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:539:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘max_size’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:539:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘max_size’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:539:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘max_size’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:540:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘resize’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:540:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘resize’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:540:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘resize’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:540:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘resize’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:541:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘capacity’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:541:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘capacity’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:541:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘capacity’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:541:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘capacity’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:542:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘reserve’; did you mean ‘reference’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:542:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘reserve’; did you mean ‘reference’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:542:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘reserve’; did you mean ‘reference’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:542:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘reserve’; did you mean ‘reference’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:546:17: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘operator[]’; did you mean ‘operator=’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~  
         { \
         ~~~      
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~      
     \
     ~            
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
     \
     ~            
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
     \
     ~            
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
 //define $
 ~~~~~~~~~~       
     $(begin)
     ~~~~~~~~     
     $(end)
     ~~~~~~       
     $(cbegin)
     ~~~~~~~~~    
     $(cend)
     ~~~~~~~      
     $(rbegin)
     ~~~~~~~~~    
     $(rend)
     ~~~~~~~      
     $(crbegin)
     ~~~~~~~~~~   
     $(crend)
     ~~~~~~~~     
     $(size)
     ~~~~~~~      
     $(length)
     ~~~~~~~~~    
     $(max_size)
     ~~~~~~~~~~~  
     $(resize)
     ~~~~~~~~~    
     $(capacity)
     ~~~~~~~~~~~  
     $(reserve)
     ~~~~~~~~~~   
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~     
     $(empty)
     ~~~~~~~~     
     $(operator [])
     ~~~~~~~~~~~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:546:17: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘operator[]’; did you mean ‘operator=’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
     \
     ~            
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
     \
     ~            
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
 //define $
 ~~~~~~~~~~       
     $(begin)
     ~~~~~~~~     
     $(end)
     ~~~~~~       
     $(cbegin)
     ~~~~~~~~~    
     $(cend)
     ~~~~~~~      
     $(rbegin)
     ~~~~~~~~~    
     $(rend)
     ~~~~~~~      
     $(crbegin)
     ~~~~~~~~~~   
     $(crend)
     ~~~~~~~~     
     $(size)
     ~~~~~~~      
     $(length)
     ~~~~~~~~~    
     $(max_size)
     ~~~~~~~~~~~  
     $(resize)
     ~~~~~~~~~    
     $(capacity)
     ~~~~~~~~~~~  
     $(reserve)
     ~~~~~~~~~~   
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~     
     $(empty)
     ~~~~~~~~     
     $(operator [])
     ~~~~~~~~~~~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:546:17: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘operator[]’; did you mean ‘operator=’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
     \
     ~            
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
 //define $
 ~~~~~~~~~~       
     $(begin)
     ~~~~~~~~     
     $(end)
     ~~~~~~       
     $(cbegin)
     ~~~~~~~~~    
     $(cend)
     ~~~~~~~      
     $(rbegin)
     ~~~~~~~~~    
     $(rend)
     ~~~~~~~      
     $(crbegin)
     ~~~~~~~~~~   
     $(crend)
     ~~~~~~~~     
     $(size)
     ~~~~~~~      
     $(length)
     ~~~~~~~~~    
     $(max_size)
     ~~~~~~~~~~~  
     $(resize)
     ~~~~~~~~~    
     $(capacity)
     ~~~~~~~~~~~  
     $(reserve)
     ~~~~~~~~~~   
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~     
     $(empty)
     ~~~~~~~~     
     $(operator [])
     ~~~~~~~~~~~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:546:17: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘operator[]’; did you mean ‘operator=’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~      
     { \
     ~~~          
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~          
 //define $
 ~~~~~~~~~~       
     $(begin)
     ~~~~~~~~     
     $(end)
     ~~~~~~       
     $(cbegin)
     ~~~~~~~~~    
     $(cend)
     ~~~~~~~      
     $(rbegin)
     ~~~~~~~~~    
     $(rend)
     ~~~~~~~      
     $(crbegin)
     ~~~~~~~~~~   
     $(crend)
     ~~~~~~~~     
     $(size)
     ~~~~~~~      
     $(length)
     ~~~~~~~~~    
     $(max_size)
     ~~~~~~~~~~~  
     $(resize)
     ~~~~~~~~~    
     $(capacity)
     ~~~~~~~~~~~  
     $(reserve)
     ~~~~~~~~~~   
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~     
     $(empty)
     ~~~~~~~~     
     $(operator [])
     ~~~~~~~~~~~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:547:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘at’; did you mean ‘data’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:547:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘at’; did you mean ‘data’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:547:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘at’; did you mean ‘data’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:547:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘at’; did you mean ‘data’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:548:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘front’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:548:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘front’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:548:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘front’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:548:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘front’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:549:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘back’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:549:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘back’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:549:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘back’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:549:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘back’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:553:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘insert’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:553:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘insert’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:553:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘insert’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:553:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘insert’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:554:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘erase’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:554:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘erase’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:554:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘erase’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:554:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘erase’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:556:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘replace’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:556:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘replace’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:556:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘replace’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:556:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘replace’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:560:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘copy’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:560:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘copy’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:560:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘copy’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:560:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘copy’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:561:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:561:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:561:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:561:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:562:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rfind’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:562:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rfind’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:562:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rfind’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:562:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘rfind’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:563:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_of’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:563:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_of’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:563:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_of’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:563:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_of’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:564:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_of’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:564:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_of’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:564:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_of’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:564:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_of’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:565:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_not_of’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:565:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_not_of’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:565:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_not_of’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:565:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_first_not_of’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:566:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_not_of’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:566:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_not_of’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:566:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_not_of’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:566:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘find_last_not_of’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
Noz.hpp:567:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘substr’; did you mean ‘c_str’?
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 let<string_tag<CharT, Traits, Allocator>> & \
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             > \
             ~~~
         { \
         ~~~
             using namespace std; \
             ~~~~~~~~~~~~~~~~~~~~~~
             auto temp_ptr = std::make_shared<std::basic_string<CharT, Traits, Allocator>>(*ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             temp_ptr->memfun(std::forward<Args>(args) ...); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             auto temp_const_ptr = std::static_pointer_cast<const std::basic_string<CharT, Traits, Allocator>>(temp_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             swap(ptr, temp_const_ptr); \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             return *this; \
             ~~~~~~~~~~~~~~~
         } \
         ~~~
     \
     ~  
     /* Override non-const member function that return value */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -> std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~~~~~~~~~~~~~~~~~~
     $(substr)
     ~~^
Noz.hpp:484:101: 備考: in definition of macro ‘$’
                 std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator> &>, \
                                                                                                     ^~~~~~
Noz.hpp:567:7: エラー: ‘class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘substr’; did you mean ‘c_str’?
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return value type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~~~~~~~~~~~~~~~~~~
     $(substr)
     ~~^
Noz.hpp:500:97: 備考: in definition of macro ‘$’
             std::is_same_v<decltype(std::declval<std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)), std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                 ^~~~~~
Noz.hpp:567:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘substr’; did you mean ‘c_str’?
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             let<string_tag<CharT, Traits, Allocator>> \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
     \
     ~  
     /* Override const member function that return other type */ \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     template<typename ... Args> \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     auto memfun(Args && ... args) const \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ->std::enable_if_t< \
         ~~~~~~~~~~~~~~~~~~~~~
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~~~~~~~~~~~~~~~~~~
     $(substr)
     ~~^
Noz.hpp:511:116: 備考: in definition of macro ‘$’
             std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                    ^~~~~~
Noz.hpp:567:7: エラー: ‘const class std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >’ has no member named ‘substr’; did you mean ‘c_str’?
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...)) \
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         > \
         ~~~
     { \
     ~~~
         return ptr->memfun(std::forward<Args>(args) ...); \
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     } \
     ~~~
 //define $
 ~~~~~~~~~~
     $(begin)
     ~~~~~~~~
     $(end)
     ~~~~~~
     $(cbegin)
     ~~~~~~~~~
     $(cend)
     ~~~~~~~
     $(rbegin)
     ~~~~~~~~~
     $(rend)
     ~~~~~~~
     $(crbegin)
     ~~~~~~~~~~
     $(crend)
     ~~~~~~~~
     $(size)
     ~~~~~~~
     $(length)
     ~~~~~~~~~
     $(max_size)
     ~~~~~~~~~~~
     $(resize)
     ~~~~~~~~~
     $(capacity)
     ~~~~~~~~~~~
     $(reserve)
     ~~~~~~~~~~
     $(shrink_to_fit)
     ~~~~~~~~~~~~~~~~
     $(clear)
     ~~~~~~~~
     $(empty)
     ~~~~~~~~
     $(operator [])
     ~~~~~~~~~~~~~~
     $(at)
     ~~~~~
     $(front)
     ~~~~~~~~
     $(back)
     ~~~~~~~
     $(append)
     ~~~~~~~~~
     $(push_back)
     ~~~~~~~~~~~~
     $(assign)
     ~~~~~~~~~
     $(insert)
     ~~~~~~~~~
     $(erase)
     ~~~~~~~~
     $(pop_back)
     ~~~~~~~~~~~
     $(replace)
     ~~~~~~~~~~
     $(c_str)
     ~~~~~~~~
     $(data)
     ~~~~~~~
     $(get_allocator)
     ~~~~~~~~~~~~~~~~
     $(copy)
     ~~~~~~~
     $(find)
     ~~~~~~~
     $(rfind)
     ~~~~~~~~
     $(find_first_of)
     ~~~~~~~~~~~~~~~~
     $(find_last_of)
     ~~~~~~~~~~~~~~~
     $(find_first_not_of)
     ~~~~~~~~~~~~~~~~~~~~
     $(find_last_not_of)
     ~~~~~~~~~~~~~~~~~~~
     $(substr)
     ~~^
Noz.hpp:522:117: 備考: in definition of macro ‘$’
             !std::is_same_v<std::decay_t<decltype(std::declval<const std::basic_string<CharT, Traits, Allocator>>().memfun(std::forward<Args>(args) ...))>, std::basic_string<CharT, Traits, Allocator>>, \
                                                                                                                     ^~~~~~
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h: In instantiation of ‘std::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::basic_string<_CharT, _Traits, _Alloc>::__sv_wrapper, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3604:58:   required from ‘std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&) [with _Tp = std::basic_string<char>; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ext/new_allocator.h:136:4:   required from ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:475:4:   required from ‘static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr_base.h:526:39:   required from ‘std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr_base.h:637:4:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:344:64:   required from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:690:14:   required from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:706:39:   required from ‘std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]’
Noz.hpp:465:76:   required from ‘constexpr Noz::let<Noz::string_tag<CharT, Traits, Allocator> >::let(Args&& ...) [with Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator_traits<char>]’
stream.hpp:52:16:   required from ‘Noz::BasicString<CharT, Traits, Allocator> Noz::BasicInputStream<CharT, Traits, Allocator>::read_line() [with CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator_traits<char>; Noz::BasicString<CharT, Traits, Allocator> = Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >]’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3614:65: エラー: no matching function for call to ‘std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >::basic_string(const char*, std::basic_string_view<char>::size_type, const std::allocator_traits<char>&)’
       : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                                                                 ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3613:7: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::basic_string<_CharT, _Traits, _Alloc>::__sv_wrapper, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
       basic_string(__sv_wrapper __svw, const _Alloc& __a)
       ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3613:7: 備考:   候補では 2 個の引数が予期されますが、3 個の引数が与えられています
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3603:2: 備考: candidate: template<class _Tp, class> std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)
  basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
  ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3603:2: 備考:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3614:65: 備考:   候補では 2 個の引数が予期されますが、3 個の引数が与えられています
       : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                                                                 ^
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3580:9: 備考: candidate: template<class _InputIterator> std::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)
         basic_string(_InputIterator __beg, _InputIterator __end,
         ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3580:9: 備考:   template argument deduction/substitution failed:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3614:65: 備考:   deduced conflicting types for parameter ‘_InputIterator’ (‘const char*’ and ‘long unsigned int’)
       : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                                                                 ^
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:53:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:684:5: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
     basic_string<_CharT, _Traits, _Alloc>::
     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:684:5: 備考:   候補では 2 個の引数が予期されますが、3 個の引数が与えられています
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3552:7: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
       basic_string(basic_string&& __str)
       ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3552:7: 備考:   候補では 1 個の引数が予期されますが、3 個の引数が与えられています
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:53:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:662:5: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
     basic_string<_CharT, _Traits, _Alloc>::
     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:662:5: 備考:   候補では 2 個の引数が予期されますが、3 個の引数が与えられています
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:609:5: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
     basic_string<_CharT, _Traits, _Alloc>::
     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:609:5: 備考:   候補では 1 個の引数が予期されますが、3 個の引数が与えられています
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:617:5: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
     basic_string<_CharT, _Traits, _Alloc>::
     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.tcc:617:5: 備考:   候補では 1 個の引数が予期されますが、3 個の引数が与えられています
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3470:7: 備考: candidate: std::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]
       basic_string()
       ^~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3470:7: 備考:   候補では 0 個の引数が予期されますが、3 個の引数が与えられています
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h: In instantiation of ‘struct std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >::_Rep’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3621:19:   required from ‘std::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3604:58:   required from ‘std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&) [with _Tp = std::basic_string<char>; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ext/new_allocator.h:136:4:   required from ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:475:4:   required from ‘static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr_base.h:526:39:   required from ‘std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr_base.h:637:4:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:344:64:   required from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:690:14:   required from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Alloc = std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> > >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:706:39:   required from ‘std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; _Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}]’
Noz.hpp:465:76:   required from ‘constexpr Noz::let<Noz::string_tag<CharT, Traits, Allocator> >::let(Args&& ...) [with Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >&}; CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator_traits<char>]’
stream.hpp:52:16:   required from ‘Noz::BasicString<CharT, Traits, Allocator> Noz::BasicInputStream<CharT, Traits, Allocator>::read_line() [with CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator_traits<char>; Noz::BasicString<CharT, Traits, Allocator> = Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >]’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3131:56: エラー: no class template named ‘rebind’ in ‘struct std::allocator_traits<char>’
  typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                                                        ^~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h: In instantiation of ‘std::basic_string<_CharT, _Traits, _Alloc>::operator std::basic_string<_CharT, _Traits, _Alloc>::__sv_type() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator_traits<char>; std::basic_string<_CharT, _Traits, _Alloc>::__sv_type = std::basic_string_view<char>]’:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3604:47:   required from ‘std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&) [with _Tp = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’
Noz.hpp:252:9:   required from ‘std::enable_if_t<is_static_castable_v<From, To>, To> Noz::try_static_cast(const From&) [with From = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >; To = std::basic_string<char>; std::enable_if_t<is_static_castable_v<From, To>, To> = std::basic_string<char>]’
Noz.hpp:265:37:   required from ‘T1 Noz::generic_cast(const T2&) [with T1 = std::basic_string<char>; T2 = std::basic_string<char, std::char_traits<char>, std::allocator_traits<char> >]’
Noz.hpp:573:31:   required from ‘Noz::let<Noz::string_tag<CharT, Traits, Allocator> >::operator U() const [with U = std::basic_string<char>; CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator_traits<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ext/new_allocator.h:136:4:   required from ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::basic_string<char>; _Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}; _Tp = std::basic_string<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/alloc_traits.h:475:4:   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr_base.h:1295:35:   required from ‘std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::basic_string<char> >; _Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}; _Tp = std::basic_string<char>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:344:64:   required from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::basic_string<char> >; _Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}; _Tp = std::basic_string<char>]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:690:14:   required from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::basic_string<char>; _Alloc = std::allocator<std::basic_string<char> >; _Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}]’
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/shared_ptr.h:706:39:   required from ‘std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = std::basic_string<char>; _Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}]’
Noz.hpp:465:76:   required from ‘constexpr Noz::let<Noz::string_tag<CharT, Traits, Allocator> >::let(Args&& ...) [with Args = {Noz::let<Noz::string_tag<char, std::char_traits<char>, std::allocator_traits<char> > >}; CharT = char; Traits = std::char_traits<char>; Allocator = std::allocator<char>]’
Noz.cpp:264:44:   required from here
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3697:38: エラー: ‘size()’ の呼び出しに適合する関数がありません
       { return __sv_type(data(), size()); }
                                  ~~~~^~
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:51:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/range_access.h:242:5: 備考: candidate: template<class _Container> constexpr decltype (__cont.size()) std::size(const _Container&)
     size(const _Container& __cont) noexcept(noexcept(__cont.size()))
     ^~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/range_access.h:242:5: 備考:   template argument deduction/substitution failed:
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3697:38: 備考:   候補では 1 個の引数が予期されますが、0 個の引数が与えられています
       { return __sv_type(data(), size()); }
                                  ~~~~^~
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:51:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/range_access.h:252:5: 備考: candidate: template<class _Tp, long unsigned int _Nm> constexpr std::size_t std::size(const _Tp (&)[_Nm])
     size(const _Tp (&/*__array*/)[_Nm]) noexcept
     ^~~~
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/range_access.h:252:5: 備考:   template argument deduction/substitution failed:
In file included from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/string:52:0,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/locale_classes.h:40,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/ios_base.h:41,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ios:42,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/ostream:38,
                 from /usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/iostream:39,
                 from Noz.hpp:4,
                 from Noz.cpp:1:
/usr/lib/gcc/x86_64-pc-cygwin/7.3.0/include/c++/bits/basic_string.h:3697:38: 備考:   候補では 1 個の引数が予期されますが、0 個の引数が与えられています
       { return __sv_type(data(), size()); }
                                  ~~~~^~
